<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿æ§åˆ¶ 3D ç²’å­ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            z-index: 2;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤º */
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(20, 20, 30, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            width: 220px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transition: transform 0.3s ease;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }
        
        h2 { margin: 0; font-size: 18px; font-weight: 500; letter-spacing: 1px; }
        
        .control-group { margin-bottom: 15px; }
        .control-label { display: block; margin-bottom: 8px; font-size: 12px; color: #aaa; text-transform: uppercase; }
        
        select, input[type="color"] {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px;
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }
        
        select:hover, input[type="color"]:hover { border-color: rgba(255, 255, 255, 0.5); }
        
        input[type="color"] { height: 40px; padding: 2px; }
        
        button#fullscreen-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, #4a90e2, #67b26f);
            border: none;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s;
            margin-top: 10px;
        }
        
        button#fullscreen-btn:hover { opacity: 0.9; }

        #status {
            margin-top: 10px;
            font-size: 12px;
            color: #4a90e2;
            text-align: center;
        }

        /* Loading overlay */
        #loading {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            flex-direction: column;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid #4a90e2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div>æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...<br>è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    </div>

    <div id="canvas-container"></div>
    
    <div id="video-container">
        <video id="input_video"></video>
    </div>

    <div id="ui-panel">
        <div class="panel-header">
            <h2>ç²’å­æ§åˆ¶å°</h2>
        </div>
        
        <div class="control-group">
            <label class="control-label">é€‰æ‹©æ¨¡å‹</label>
            <select id="model-select">
                <option value="heart">â¤ï¸ çˆ±å¿ƒ</option>
                <option value="tree">ğŸ„ åœ£è¯æ ‘</option>
                <option value="flower">ğŸŒ¸ èŠ±æœµ</option>
                <option value="saturn">ğŸª åœŸæ˜Ÿ</option>
                <option value="buddha">ğŸ§˜ ä½›åƒ (æŠ½è±¡)</option>
                <option value="fireworks">ğŸ† çƒŸèŠ±</option>
            </select>
        </div>
        
        <div class="control-group">
            <label class="control-label">ç²’å­é¢œè‰²</label>
            <input type="color" id="color-picker" value="#ff0055">
        </div>

        <div class="control-group">
            <label class="control-label">çŠ¶æ€</label>
            <div id="gesture-status">ç­‰å¾…æ‰‹åŠ¿...</div>
        </div>
        
        <button id="fullscreen-btn">å…¨å±æ¨¡å¼</button>
    </div>

    <script>
        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer;
        let particles, particleGeometry, particleMaterial;
        let particleGroup;
        let specialSprites = [];
        let specialTextures = [];
        let imageFiles = [
            '3c93cd605bcce9c78f2dbf50a453f07b.jpg',
            '7c710fcc5ffa7649ec2d6c061b3faf8c.jpg',
            'c5205ed2b432f0a2402fce6ce1aa87d1.jpg',
            'fa4baa0ee98cb89e09664bdef32f7e8f.jpg'
        ];
        let lastGesture = 'none';
        let activeImageIndex = -1;
        let targetPositions = []; // ç›®æ ‡ä½ç½®æ•°ç»„
        let currentPositions = []; // å½“å‰ä½ç½®æ•°ç»„
        const particleCount = 15000; // ç²’å­æ•°é‡
        let currentShape = 'heart';
        let baseColor = new THREE.Color(0xff0055);
        let handDistance = 0.5; // é»˜è®¤æ‰‹åŠ¿è·ç¦» (0-1)
        let targetScale = 1.0;
        let isHandsDetected = false;
        let targetRotationX = 0;
        let targetRotationY = 0;

        // --- åˆå§‹åŒ– Three.js ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            particleGroup = new THREE.Group();
            scene.add(particleGroup);

            // Load textures
            const textureLoader = new THREE.TextureLoader();
            imageFiles.forEach(file => {
                specialTextures.push(textureLoader.load(file));
            });

            // Create 8 sprites
            for(let i=0; i<8; i++) {
                const texIndex = Math.floor(i / 2);
                const mat = new THREE.SpriteMaterial({ map: specialTextures[texIndex], color: 0xffffff });
                const sprite = new THREE.Sprite(mat);
                sprite.scale.set(2, 2, 1);
                particleGroup.add(sprite);
                specialSprites.push({
                    mesh: sprite,
                    targetPos: new THREE.Vector3(),
                    currentPos: new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100),
                    isActive: false,
                    offset: (i % 2 === 0) ? -3 : 3
                });
            }

            // ç²’å­ç³»ç»Ÿåˆå§‹åŒ–
            particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            // åˆå§‹éšæœºä½ç½®å’Œé¢œè‰²
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 100;
                currentPositions[i] = positions[i];
                colors[i] = 1.0; // Default white
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // åˆ›å»ºè‡ªå®šä¹‰ç€è‰²å™¨æè´¨ä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½å’Œæ•ˆæœ
            // è¿™é‡Œä¸ºäº†ç®€åŒ–ä½¿ç”¨ PointsMaterialï¼Œä½†é…åˆè´´å›¾ä¼šæ›´å¥½
            // åŠ¨æ€ç”Ÿæˆä¸€ä¸ªåœ†å½¢çº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);

            particleMaterial = new THREE.PointsMaterial({
                color: baseColor,
                size: 0.5,
                map: texture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: true
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            particleGroup.add(particles);

            // ç”Ÿæˆåˆå§‹å½¢çŠ¶
            generateShape('heart');

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
            
            // åŠ¨ç”»å¾ªç¯
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- å½¢çŠ¶ç”Ÿæˆå™¨ ---
        function generateShape(type) {
            targetPositions = [];
            const scale = 10;
            const colors = particles.geometry.attributes.color.array;
            
            // Reset colors to white for non-tree shapes, or specific colors for tree
            if (type === 'tree') {
                particleMaterial.color.setHex(0xffffff); // Use vertex colors
            } else {
                particleMaterial.color.set(baseColor); // Use base color (tint)
            }

            if (type === 'heart') {
                for (let i = 0; i < particleCount; i++) {
                    colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
                    // å¿ƒå½¢å…¬å¼
                    // x = 16sin^3(t)
                    // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                    // æ‰©å±•åˆ°3D: ç»•yè½´æ—‹è½¬æˆ–æ·»åŠ éšæœºzæ·±åº¦
                    
                    // ä½¿ç”¨æ›´ç«‹ä½“çš„ç”Ÿæˆæ–¹å¼
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    
                    // åŸºç¡€å¿ƒå½¢æ›²çº¿
                    let t = Math.random() * Math.PI * 2;
                    let x = 16 * Math.pow(Math.sin(t), 3);
                    let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    let z = (Math.random() - 0.5) * 5; // ç®€å•çš„åšåº¦

                    // ç¨å¾®éšæœºåŒ–ä»¥å¡«å……ä½“ç§¯
                    x += (Math.random() - 0.5);
                    y += (Math.random() - 0.5);
                    
                    targetPositions.push(x * 0.5, y * 0.5, z * 0.5);
                }
            } else if (type === 'tree') {
                for (let i = 0; i < particleCount; i++) {
                    // Star at the top (first 50 particles)
                    if (i < 50) {
                        const r = Math.random() * 1.5;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        
                        const x = r * Math.sin(phi) * Math.cos(theta);
                        const y = 16 + r * Math.sin(phi) * Math.sin(theta); // Top at y=16
                        const z = r * Math.cos(phi);
                        targetPositions.push(x, y, z);
                        
                        // Yellow Star
                        colors[i*3] = 1.0; colors[i*3+1] = 1.0; colors[i*3+2] = 0.0;
                    } else {
                        // Spiral Tree
                        const t = (i - 50) / (particleCount - 50);
                        const y = -15 + t * 30; // Height from -15 to 15
                        
                        // Radius decreases linearly as we go up
                        const maxRadius = (15 - y) * 0.5;
                        
                        // Spiral angle: rotates as we go up
                        const angle = y * 2.5 + (Math.random() - 0.5) * 0.5; 
                        
                        // Add some thickness to the spiral
                        const r = maxRadius * (0.8 + Math.random() * 0.2);
                        
                        const x = r * Math.cos(angle);
                        const z = r * Math.sin(angle);
                        
                        targetPositions.push(x, y, z);

                        // Tree Body Colors: Green (3) : Silver (1)
                        if (Math.random() > 0.25) {
                            // Green
                            colors[i*3] = 0.1; colors[i*3+1] = 0.8; colors[i*3+2] = 0.2;
                        } else {
                            // Silver
                            colors[i*3] = 0.9; colors[i*3+1] = 0.9; colors[i*3+2] = 0.9;
                        }
                    }
                }
            } else if (type === 'flower') {
                for (let i = 0; i < particleCount; i++) {
                    colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
                    // ç«ç‘°çº¿ r = cos(k*theta)
                    const k = 4; // èŠ±ç“£æ•°
                    const theta = Math.random() * Math.PI * 2;
                    const phi = (Math.random() - 0.5) * Math.PI; // Zè½´åˆ†å¸ƒ
                    
                    const r = Math.cos(k * theta) * 10 + 2; // +2 ä¿è¯ä¸­å¿ƒæœ‰ç©ºæ´æˆ–åšåº¦
                    
                    const x = r * Math.cos(theta) * Math.cos(phi);
                    const y = r * Math.sin(theta) * Math.cos(phi);
                    const z = r * Math.sin(phi) * 0.5; // å‹æ‰ä¸€ç‚¹

                    targetPositions.push(x, y, z);
                }
            } else if (type === 'saturn') {
                const sphereCount = Math.floor(particleCount * 0.4);
                const ringCount = particleCount - sphereCount;
                
                for (let i = 0; i < sphereCount; i++) {
                    colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
                    const r = 6;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta);
                    const z = r * Math.cos(phi);
                    targetPositions.push(x, y, z);
                }
                
                for (let i = 0; i < ringCount; i++) {
                    const idx = sphereCount + i;
                    colors[idx*3] = 1; colors[idx*3+1] = 1; colors[idx*3+2] = 1;
                    const innerR = 8;
                    const outerR = 14;
                    const r = innerR + Math.random() * (outerR - innerR);
                    const theta = Math.random() * Math.PI * 2;
                    
                    const x = r * Math.cos(theta);
                    const z = r * Math.sin(theta);
                    const y = (Math.random() - 0.5) * 0.5; // è–„è–„çš„ä¸€å±‚
                    
                    const tilt = Math.PI / 6;
                    const x_rot = x * Math.cos(tilt) - y * Math.sin(tilt);
                    const y_rot = x * Math.sin(tilt) + y * Math.cos(tilt);
                    
                    targetPositions.push(x_rot, y_rot, z);
                }
            } else if (type === 'buddha') {
                const geometry = new THREE.TorusKnotGeometry(6, 2, 100, 16);
                const posAttribute = geometry.attributes.position;
                const count = posAttribute.count;
                
                for (let i = 0; i < particleCount; i++) {
                    colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
                    const index = Math.floor(Math.random() * count);
                    const x = posAttribute.getX(index) + (Math.random() - 0.5) * 0.5;
                    const y = posAttribute.getY(index) + (Math.random() - 0.5) * 0.5;
                    const z = posAttribute.getZ(index) + (Math.random() - 0.5) * 0.5;
                    targetPositions.push(x, y, z);
                }
            } else if (type === 'fireworks') {
                for (let i = 0; i < particleCount; i++) {
                    colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
                    const r = Math.random() * 15;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta);
                    const z = r * Math.cos(phi);
                    targetPositions.push(x, y, z);
                }
            }

            particles.geometry.attributes.color.needsUpdate = true;

            for(let i=0; i<8; i++) {
                const randIdx = Math.floor(Math.random() * particleCount);
                specialSprites[i].targetPos.set(
                    targetPositions[randIdx*3],
                    targetPositions[randIdx*3+1],
                    targetPositions[randIdx*3+2]
                );
                specialSprites[i].isActive = false;
                specialSprites[i].mesh.scale.set(2, 2, 1);
                specialSprites[i].mesh.material.opacity = 0.8;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const positions = particles.geometry.attributes.position.array;
            
            let currentScale = 1.0;
            let spreadFactor = 0.05; // ç§»åŠ¨é€Ÿåº¦

            if (isHandsDetected) {
                particleGroup.rotation.x += (targetRotationX - particleGroup.rotation.x) * 0.1;
                particleGroup.rotation.y += (targetRotationY - particleGroup.rotation.y) * 0.1;

                const targetS = 0.5 + (handDistance * 4); 
                targetScale += (targetS - targetScale) * 0.1; 
                spreadFactor = 0.1; 
            } else {
                particleGroup.rotation.y += 0.002;
                particleGroup.rotation.x += (0 - particleGroup.rotation.x) * 0.05;

                const time = Date.now() * 0.001;
                targetScale = 1.0 + Math.sin(time) * 0.1;
            }

            specialSprites.forEach(spriteObj => {
                let target = spriteObj.targetPos.clone().multiplyScalar(targetScale);
                
                let baseSize = 2; // Default size
                if (spriteObj.isActive) baseSize = 16; // Larger size for active

                let scaleX = baseSize;
                let scaleY = baseSize;
                
                const tex = spriteObj.mesh.material.map;
                if (tex && tex.image && tex.image.width) {
                    const aspect = tex.image.width / tex.image.height;
                    if (aspect >= 1) {
                        scaleX = baseSize;
                        scaleY = baseSize / aspect;
                    } else {
                        scaleY = baseSize;
                        scaleX = baseSize * aspect;
                    }
                }

                if (spriteObj.isActive) {
                    target.set(0, 0, 10); 
                    spriteObj.mesh.material.opacity = 1;
                    spriteObj.mesh.material.depthTest = false;
                } else {
                    spriteObj.mesh.material.opacity = 0.8;
                    spriteObj.mesh.material.depthTest = true;
                }
                
                spriteObj.mesh.scale.lerp(new THREE.Vector3(scaleX, scaleY, 1), 0.1);
                spriteObj.currentPos.lerp(target, spreadFactor);
                spriteObj.mesh.position.copy(spriteObj.currentPos);
            });

            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const tx = targetPositions[ix] * targetScale;
                const ty = targetPositions[iy] * targetScale;
                const tz = targetPositions[iz] * targetScale;

                positions[ix] += (tx - positions[ix]) * spreadFactor;
                positions[iy] += (ty - positions[iy]) * spreadFactor;
                positions[iz] += (tz - positions[iz]) * spreadFactor;
                
                if (currentShape === 'fireworks') {
                     positions[iy] -= 0.05; // é‡åŠ›æ•ˆæœ
                     if (positions[iy] < -15) positions[iy] = 15;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function initMediaPipe() {
            const videoElement = document.getElementById('input_video');
            const statusElement = document.getElementById('gesture-status');

            if (typeof Hands === 'undefined') {
                statusElement.innerText = "JSåº“åŠ è½½å¤±è´¥\nè¯·æ£€æŸ¥ç½‘ç»œ";
                statusElement.style.color = "red";
                return;
            }

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 0, // 0: Lite, 1: Full
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    try {
                        await hands.send({image: videoElement});
                    } catch (error) {
                        console.error("MediaPipe Send Error:", error);
                    }
                },
                width: 320,
                height: 240
            });
            
            statusElement.innerText = "æ­£åœ¨åŠ è½½æ¨¡å‹...";
            
            setTimeout(() => {
                if (statusElement.innerText === "æ­£åœ¨åŠ è½½æ¨¡å‹...") {
                    statusElement.innerText = "æ¨¡å‹åŠ è½½è¶…æ—¶\nè¯·æ£€æŸ¥ç½‘ç»œ(å¯èƒ½éœ€è¦ä»£ç†)";
                    statusElement.style.color = "orange";
                }
            }, 20000);

            camera.start()
                .then(() => {
                    document.getElementById('loading').style.display = 'none';
                    console.log("Camera started");
                })
                .catch(err => {
                    console.error("Camera error:", err);
                    document.getElementById('loading').innerHTML = "æ— æ³•è®¿é—®æ‘„åƒå¤´<br>è¯·æ£€æŸ¥æƒé™æˆ–è®¾å¤‡";
                });
        }

        function detectGesture(landmarks) {
            if (!landmarks) return 'none';
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distThumbIndex = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            
            const isMiddleExtended = landmarks[12].y < landmarks[10].y;
            const isRingExtended = landmarks[16].y < landmarks[14].y;
            const isPinkyExtended = landmarks[20].y < landmarks[18].y;
            const isIndexExtended = landmarks[8].y < landmarks[6].y;
            
            const isFingersExtended = isMiddleExtended && isRingExtended && isPinkyExtended;
            const isFingersFolded = !isMiddleExtended && !isRingExtended && !isPinkyExtended && !isIndexExtended;

            if (distThumbIndex < 0.08 && isFingersExtended) return 'ok';
            if (distThumbIndex > 0.15 && isIndexExtended && isFingersExtended) return 'open';
            if (isFingersFolded) return 'fist';
            
            return 'other';
        }

        function triggerImageDisplay() {
            specialSprites.forEach(s => s.isActive = false);
            const spriteIdx = Math.floor(Math.random() * 8);
            specialSprites[spriteIdx].isActive = true;
        }

        function resetImages() {
            specialSprites.forEach(s => s.isActive = false);
        }

        function onResults(results) {
            const statusElement = document.getElementById('gesture-status');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandsDetected = true;

                const gesture = detectGesture(results.multiHandLandmarks[0]);
                
                if (gesture === 'ok' && lastGesture === 'open') {
                    triggerImageDisplay();
                    statusElement.innerText = "å›¾ç‰‡å±•ç¤ºä¸­ (æ¡æ‹³å…³é—­)";
                    statusElement.style.color = '#ff00ff';
                } else if (gesture === 'fist') {
                    resetImages();
                    statusElement.innerText = "å›¾ç‰‡å·²å…³é—­";
                    statusElement.style.color = '#aaa';
                }
                
                lastGesture = gesture;

                let cx = 0.5;
                let cy = 0.5;
                
                if (results.multiHandLandmarks.length === 2) {
                    const hand1 = results.multiHandLandmarks[0];
                    const hand2 = results.multiHandLandmarks[1];
                    
                    const p1 = hand1[8];
                    const p2 = hand2[8];
                    
                    const distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                    
                    handDistance = distance;

                    cx = (p1.x + p2.x) / 2;
                    cy = (p1.y + p2.y) / 2;

                    statusElement.innerText = `åŒæ‰‹æ§åˆ¶ä¸­: ${(distance * 100).toFixed(0)}%`;
                    statusElement.style.color = '#4caf50';
                } else {
                    const hand = results.multiHandLandmarks[0];
                    const p1 = hand[4];
                    const p2 = hand[8];
                    const distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                    
                    handDistance = distance * 3; 

                    cx = hand[9].x;
                    cy = hand[9].y;

                    statusElement.innerText = `å•æ‰‹æåˆæ§åˆ¶`;
                    statusElement.style.color = '#ff9800';
                }

                targetRotationY = (cx - 0.5) * Math.PI * 2; 
                targetRotationX = (cy - 0.5) * Math.PI;

            } else {
                isHandsDetected = false;
                statusElement.innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
                statusElement.style.color = '#aaa';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initThree();
            initMediaPipe();

            document.getElementById('model-select').addEventListener('change', (e) => {
                currentShape = e.target.value;
                generateShape(currentShape);
            });

            document.getElementById('color-picker').addEventListener('input', (e) => {
                const color = new THREE.Color(e.target.value);
                particleMaterial.color = color;
            });

            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            });
        });

    </script>
</body>
</html>